use anyhow::Result;
use chrono::Local;
use std::path::Path;

use crate::templates;

/// Generates comprehensive AI agent documentation for a target project
///
/// This function combines various templates to create a complete documentation
/// file that instructs AI coding agents on best practices, continuous improvement,
/// and tool usage.
///
/// # Arguments
///
/// * `target_path` - Path to the target project directory
/// * `verbose` - Whether to output verbose information during generation
///
/// # Returns
///
/// Returns the generated documentation as a String, or an error if generation fails.
pub fn generate_documentation(target_path: &Path, verbose: bool) -> Result<String> {
    if verbose {
        eprintln!("Generating documentation for: {}", target_path.display());
    }

    let mut doc = String::new();

    // Add header with metadata
    doc.push_str(&generate_header(target_path));
    doc.push('\n');

    // Add process guidelines
    if verbose {
        eprintln!("  Adding process guidelines...");
    }
    doc.push_str(templates::process_guidelines());
    doc.push('\n');

    // Add quality standards
    if verbose {
        eprintln!("  Adding quality standards...");
    }
    doc.push_str(templates::quality_standards());
    doc.push('\n');

    // Add continuous improvement section
    if verbose {
        eprintln!("  Adding continuous improvement practices...");
    }
    doc.push_str(templates::continuous_improvement());
    doc.push('\n');

    // Add Playwright MCP setup instructions
    if verbose {
        eprintln!("  Adding Playwright MCP setup instructions...");
    }
    doc.push_str(templates::playwright_mcp_setup());
    doc.push('\n');

    // Add project-specific notes if applicable
    if let Some(notes) = generate_project_specific_notes(target_path, verbose)? {
        if verbose {
            eprintln!("  Adding project-specific notes...");
        }
        doc.push_str(&notes);
        doc.push('\n');
    }

    // Add summary
    if verbose {
        eprintln!("  Adding summary...");
    }
    doc.push_str(templates::summary());

    Ok(doc)
}

/// Generates the header section with metadata
fn generate_header(target_path: &Path) -> String {
    let project_name = target_path
        .file_name()
        .and_then(|n| n.to_str())
        .unwrap_or("Unknown Project");

    let timestamp = Local::now().format("%Y-%m-%d %H:%M:%S").to_string();

    format!(
        r#"<!-- 
Generated by Proact for: {project_name}
Generated at: {timestamp}
-->
"#
    )
}

/// Generates project-specific notes based on detected project characteristics
fn generate_project_specific_notes(target_path: &Path, verbose: bool) -> Result<Option<String>> {
    let mut notes = Vec::new();

    // Check for common project files and add relevant notes
    let cargo_toml = target_path.join("Cargo.toml");
    let package_json = target_path.join("package.json");
    let pyproject_toml = target_path.join("pyproject.toml");
    let requirements_txt = target_path.join("requirements.txt");
    let go_mod = target_path.join("go.mod");

    if cargo_toml.exists() {
        if verbose {
            eprintln!("    Detected Rust project");
        }
        notes.push(rust_specific_notes());
    }

    if package_json.exists() {
        if verbose {
            eprintln!("    Detected Node.js/JavaScript project");
        }
        notes.push(javascript_specific_notes());
    }

    if pyproject_toml.exists() || requirements_txt.exists() {
        if verbose {
            eprintln!("    Detected Python project");
        }
        notes.push(python_specific_notes());
    }

    if go_mod.exists() {
        if verbose {
            eprintln!("    Detected Go project");
        }
        notes.push(go_specific_notes());
    }

    if notes.is_empty() {
        Ok(None)
    } else {
        let mut result = String::from("## Project-Specific Guidelines\n\n");
        result.push_str(&notes.join("\n"));
        result.push_str("\n\n---\n");
        Ok(Some(result))
    }
}

/// Returns Rust-specific development notes
fn rust_specific_notes() -> String {
    r#"### Rust Development
- Use `cargo build` to compile the project
- Use `cargo test` to run all tests
- Use `cargo clippy` for linting
- Use `cargo fmt` for code formatting
- Use `cargo doc --open` to generate and view documentation
- Follow Rust naming conventions (snake_case for functions/variables, CamelCase for types)
- Ensure all public items have documentation comments"#
        .to_string()
}

/// Returns JavaScript/Node.js-specific development notes
fn javascript_specific_notes() -> String {
    r#"### JavaScript/Node.js Development
- Use `npm install` or `yarn install` to install dependencies
- Use `npm test` or `yarn test` to run tests
- Use `npm run lint` or `yarn lint` for linting (if configured)
- Use `prettier` for code formatting (if available)
- Follow JavaScript naming conventions (camelCase for functions/variables, PascalCase for classes)
- Use JSDoc comments for function documentation"#
        .to_string()
}

/// Returns Python-specific development notes
fn python_specific_notes() -> String {
    r#"### Python Development
- Use `pip install -r requirements.txt` or `poetry install` for dependencies
- Use `pytest` or `python -m unittest` to run tests
- Use `pylint`, `flake8`, or `ruff` for linting
- Use `black` for code formatting
- Follow PEP 8 style guidelines
- Use docstrings for all functions, classes, and modules"#
        .to_string()
}

/// Returns Go-specific development notes
fn go_specific_notes() -> String {
    r#"### Go Development
- Use `go build` to compile the project
- Use `go test ./...` to run all tests
- Use `go vet` for static analysis
- Use `go fmt` or `gofmt` for code formatting
- Use `golint` or `golangci-lint` for additional linting
- Follow Go naming conventions and idioms
- Write table-driven tests where appropriate"#
        .to_string()
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use std::path::PathBuf;

    #[test]
    fn test_generate_documentation() {
        let temp_dir = std::env::temp_dir().join("proact_test");
        fs::create_dir_all(&temp_dir).unwrap();

        let result = generate_documentation(&temp_dir, false);
        assert!(result.is_ok());

        let doc = result.unwrap();
        assert!(doc.contains("AI Coding Agent Development Process Guidelines"));
        assert!(doc.contains("Quality-Oriented Development"));
        assert!(doc.contains("Continuous Improvement"));
        assert!(doc.contains("Playwright MCP"));

        // Clean up
        let _ = fs::remove_dir_all(&temp_dir);
    }

    #[test]
    fn test_generate_header() {
        let path = PathBuf::from("/test/project");
        let header = generate_header(&path);
        assert!(header.contains("Generated by Proact"));
        assert!(header.contains("project"));
    }

    #[test]
    fn test_rust_project_detection() {
        let temp_dir = std::env::temp_dir().join("proact_rust_test");
        fs::create_dir_all(&temp_dir).unwrap();
        fs::write(temp_dir.join("Cargo.toml"), "[package]").unwrap();

        let notes = generate_project_specific_notes(&temp_dir, false).unwrap();
        assert!(notes.is_some());
        assert!(notes.unwrap().contains("Rust Development"));

        // Clean up
        let _ = fs::remove_dir_all(&temp_dir);
    }

    #[test]
    fn test_javascript_project_detection() {
        let temp_dir = std::env::temp_dir().join("proact_js_test");
        fs::create_dir_all(&temp_dir).unwrap();
        fs::write(temp_dir.join("package.json"), "{}").unwrap();

        let notes = generate_project_specific_notes(&temp_dir, false).unwrap();
        assert!(notes.is_some());
        assert!(notes.unwrap().contains("JavaScript/Node.js Development"));

        // Clean up
        let _ = fs::remove_dir_all(&temp_dir);
    }

    #[test]
    fn test_python_project_detection() {
        let temp_dir = std::env::temp_dir().join("proact_py_test");
        fs::create_dir_all(&temp_dir).unwrap();
        fs::write(temp_dir.join("requirements.txt"), "").unwrap();

        let notes = generate_project_specific_notes(&temp_dir, false).unwrap();
        assert!(notes.is_some());
        assert!(notes.unwrap().contains("Python Development"));

        // Clean up
        let _ = fs::remove_dir_all(&temp_dir);
    }
}
