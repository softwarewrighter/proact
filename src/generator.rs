use anyhow::Result;
use chrono::Local;
use std::fs;
use std::path::Path;

use crate::metadata::{self, ProjectMetadata};
use crate::templates;

/// Generates comprehensive AI agent documentation for a target project
///
/// This function combines various templates to create a complete documentation
/// file that instructs AI coding agents on best practices, continuous improvement,
/// and tool usage.
///
/// # Arguments
///
/// * `target_path` - Path to the target project directory
/// * `verbose` - Whether to output verbose information during generation
///
/// # Returns
///
/// Returns the generated documentation as a String, or an error if generation fails.
pub fn generate_documentation(target_path: &Path, verbose: bool) -> Result<String> {
    if verbose {
        eprintln!("Generating documentation for: {}", target_path.display());
    }

    let mut doc = String::new();

    // Add header with metadata
    doc.push_str(&generate_header(target_path));
    doc.push('\n');

    // Add process guidelines
    if verbose {
        eprintln!("  Adding process guidelines...");
    }
    doc.push_str(templates::process_guidelines());
    doc.push('\n');

    // Add quality standards
    if verbose {
        eprintln!("  Adding quality standards...");
    }
    doc.push_str(templates::quality_standards());
    doc.push('\n');

    // Add continuous improvement section
    if verbose {
        eprintln!("  Adding continuous improvement practices...");
    }
    doc.push_str(templates::continuous_improvement());
    doc.push('\n');

    // Add Playwright MCP setup instructions
    if verbose {
        eprintln!("  Adding Playwright MCP setup instructions...");
    }
    doc.push_str(templates::playwright_mcp_setup());
    doc.push('\n');

    // Add project-specific notes if applicable
    if let Some(notes) = generate_project_specific_notes(target_path, verbose)? {
        if verbose {
            eprintln!("  Adding project-specific notes...");
        }
        doc.push_str(&notes);
        doc.push('\n');
    }

    // Add summary
    if verbose {
        eprintln!("  Adding summary...");
    }
    doc.push_str(templates::summary());

    Ok(doc)
}

/// Generates the header section with metadata
fn generate_header(target_path: &Path) -> String {
    let project_name = target_path
        .file_name()
        .and_then(|n| n.to_str())
        .unwrap_or("Unknown Project");

    let timestamp = Local::now().format("%Y-%m-%d %H:%M:%S").to_string();

    format!(
        r#"<!-- 
Generated by Proact for: {project_name}
Generated at: {timestamp}
-->
"#
    )
}

/// Generates project-specific notes based on detected project characteristics
fn generate_project_specific_notes(target_path: &Path, verbose: bool) -> Result<Option<String>> {
    let mut notes = Vec::new();

    // Check for common project files and add relevant notes
    let cargo_toml = target_path.join("Cargo.toml");
    let package_json = target_path.join("package.json");
    let pyproject_toml = target_path.join("pyproject.toml");
    let requirements_txt = target_path.join("requirements.txt");

    if cargo_toml.exists() {
        if verbose {
            eprintln!("    Detected Rust project");
        }
        notes.push(rust_specific_notes());
    }

    if package_json.exists() {
        if verbose {
            eprintln!("    Detected Node.js/JavaScript project");
        }
        notes.push(javascript_specific_notes());
    }

    if pyproject_toml.exists() || requirements_txt.exists() {
        if verbose {
            eprintln!("    Detected Python project");
        }
        notes.push(python_specific_notes());
    }

    if notes.is_empty() {
        Ok(None)
    } else {
        let mut result = String::from("## Project-Specific Guidelines\n\n");
        result.push_str(&notes.join("\n"));
        result.push_str("\n\n---\n");
        Ok(Some(result))
    }
}

/// Returns Rust-specific development notes
fn rust_specific_notes() -> String {
    r#"### Rust Development
- Use `cargo build` to compile the project
- Use `cargo test` to run all tests
- Use `cargo clippy --all-targets --all-features -- -D warnings` for strict linting
- Use `cargo fmt` for code formatting
- Use `cargo doc --open` to generate and view documentation
- Follow Rust naming conventions (snake_case for functions/variables, CamelCase for types)
- Ensure all public items have documentation comments
- Use Rust 2024 edition features where applicable
- Prefer `let-else` patterns for error handling where appropriate
- Use workspace dependencies for multi-crate projects

### Rust/WASM Projects
- Keep JavaScript to absolute minimum - only for WASM loading
- All business logic must be in Rust
- Use `wasm-bindgen` for JS interop
- Use `wasm-pack` for building and packaging
- Write tests in Rust using `wasm-bindgen-test`, not in JavaScript
- Use `web-sys` for DOM manipulation from Rust
- Minimize JS bundle size - let Rust handle the complexity"#
        .to_string()
}

/// Returns JavaScript/Node.js-specific development notes
fn javascript_specific_notes() -> String {
    r#"### JavaScript/Node.js Development
- Use `npm install` or `yarn install` to install dependencies
- Use `npm test` or `yarn test` to run tests
- Use `npm run lint` or `yarn lint` for linting (if configured)
- Use `prettier` for code formatting (if available)
- Follow JavaScript naming conventions (camelCase for functions/variables, PascalCase for classes)
- Use JSDoc comments for function documentation"#
        .to_string()
}

/// Returns Python-specific development notes
fn python_specific_notes() -> String {
    r#"### Python Development
- Use `uv` for dependency management (preferred over pip/conda)
  - `uv pip install -r requirements.txt` for installing dependencies
  - `uv venv` for virtual environment creation
  - `uv pip compile requirements.in` for dependency locking
- Use `pytest` to run tests (avoid unittest)
- Use `ruff` for linting and formatting (replaces black, flake8, pylint, isort)
  - `ruff check` for linting
  - `ruff format` for formatting
- Follow PEP 8 style guidelines
- Use type hints for all function signatures
- Use docstrings for all functions, classes, and modules"#
        .to_string()
}

// Embed template files at compile time
const PROCESS_MD_TEMPLATE: &str = include_str!("../templates/process.md");
const TOOLS_MD_TEMPLATE: &str = include_str!("../templates/tools.md");

/// Copy or append template files to output directory
pub fn copy_templates(output_dir: &Path, verbose: bool, dry_run: bool) -> Result<()> {
    let templates_to_copy = vec![
        (PROCESS_MD_TEMPLATE, "process.md"),
        (TOOLS_MD_TEMPLATE, "tools.md"),
    ];

    for (source_content, dest_name) in templates_to_copy {
        let dest_path = output_dir.join(dest_name);

        // Check if destination already exists
        if dest_path.exists() {
            // Append to existing file with separator
            let timestamp = Local::now().format("%Y-%m-%d %H:%M:%S").to_string();
            let separator = format!(
                "\n\n---\n\n**The following content was added by [Proact](https://github.com/softwarewrighter/proact) on {}**\n\n",
                timestamp
            );
            let existing_content = fs::read_to_string(&dest_path)?;
            let combined = format!("{existing_content}{separator}{source_content}");

            if verbose {
                eprintln!(
                    "append {} (existing: {} bytes + separator + new: {} bytes)",
                    dest_path.display(),
                    existing_content.len(),
                    source_content.len()
                );
            }

            if !dry_run {
                fs::write(dest_path, combined)?;
            }
        } else {
            // Write new file
            if verbose {
                eprintln!(
                    "write {} ({} bytes)",
                    dest_path.display(),
                    source_content.len()
                );
            }

            if !dry_run {
                fs::write(dest_path, source_content)?;
            }
        }
    }

    Ok(())
}

/// Generate COPYRIGHT and LICENSE files based on project metadata
/// Files are written to the target project root directory
pub fn generate_legal_files(
    target_path: &Path,
    _output_dir: &Path,
    verbose: bool,
    dry_run: bool,
) -> Result<()> {
    let metadata = ProjectMetadata::extract(target_path)?;

    // Generate COPYRIGHT file in target project root
    let copyright_content = metadata.copyright_string();
    let copyright_path = target_path.join("COPYRIGHT");

    if verbose {
        eprintln!(
            "write {} ({} bytes)",
            copyright_path.display(),
            copyright_content.len()
        );
    }

    if !dry_run {
        fs::write(copyright_path, copyright_content)?;
    }

    // Generate LICENSE file in target project root (currently only MIT supported)
    if metadata.license == "MIT" || metadata.license == "<license>" {
        let license_content = metadata::generate_mit_license(&metadata);
        let license_path = target_path.join("LICENSE");

        if verbose {
            eprintln!(
                "write {} ({} bytes)",
                license_path.display(),
                license_content.len()
            );
        }

        if !dry_run {
            fs::write(license_path, license_content)?;
        }
    } else if verbose {
        eprintln!(
            "# License type '{}' not yet supported for auto-generation, skipping LICENSE file",
            metadata.license
        );
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use std::path::PathBuf;

    /// Get test output directory path
    fn get_test_dir(test_name: &str) -> PathBuf {
        PathBuf::from("test-output").join(test_name)
    }

    /// Setup test directory - removes old artifacts if present
    fn setup_test_dir(test_name: &str) -> PathBuf {
        let dir = get_test_dir(test_name);
        // Clean up any previous test artifacts
        let _ = fs::remove_dir_all(&dir);
        fs::create_dir_all(&dir).unwrap();
        dir
    }

    #[test]
    fn test_generate_documentation() {
        let temp_dir = setup_test_dir("generate_doc");

        let result = generate_documentation(&temp_dir, false);
        assert!(result.is_ok());

        let doc = result.unwrap();
        assert!(doc.contains("AI Coding Agent Development Process Guidelines"));
        assert!(doc.contains("Quality-Oriented Development"));
        assert!(doc.contains("Continuous Improvement"));
        assert!(doc.contains("Playwright MCP"));

        // No cleanup - leave for inspection
    }

    #[test]
    fn test_generate_header() {
        let path = PathBuf::from("/test/project");
        let header = generate_header(&path);
        assert!(header.contains("Generated by Proact"));
        assert!(header.contains("project"));
    }

    #[test]
    fn test_rust_project_detection() {
        let temp_dir = setup_test_dir("rust_detection");
        fs::write(temp_dir.join("Cargo.toml"), "[package]").unwrap();

        let notes = generate_project_specific_notes(&temp_dir, false).unwrap();
        assert!(notes.is_some());
        assert!(notes.unwrap().contains("Rust Development"));

        // No cleanup - leave for inspection
    }

    #[test]
    fn test_javascript_project_detection() {
        let temp_dir = setup_test_dir("js_detection");
        fs::write(temp_dir.join("package.json"), "{}").unwrap();

        let notes = generate_project_specific_notes(&temp_dir, false).unwrap();
        assert!(notes.is_some());
        assert!(notes.unwrap().contains("JavaScript/Node.js Development"));

        // No cleanup - leave for inspection
    }

    #[test]
    fn test_python_project_detection() {
        let temp_dir = setup_test_dir("python_detection");
        fs::write(temp_dir.join("requirements.txt"), "").unwrap();

        let notes = generate_project_specific_notes(&temp_dir, false).unwrap();
        assert!(notes.is_some());
        assert!(notes.unwrap().contains("Python Development"));

        // No cleanup - leave for inspection
    }
}
